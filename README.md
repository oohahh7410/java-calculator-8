# 문자열 덧셈 계산기

문자열 속에 숨겨진 숫자들을 찾아 꺼내 합을 구하는 프로그램입니다.
쉼표(,)나 콜론(:)으로 구분된 기본 입력은 물론, 사용자가 직접 정의한 구분자도 인식할 수 있습니다.

---

## 주요 기능

**입력 처리**
- `Console.readLine()`으로 사용자 입력
- `null`이나 빈 문자열은 `0` 반환
- 공백만 있는 경우도 빈 문자열로 처리

**구분자 처리**
- 기본 구분자(`,`, `:`) 지원
- 커스텀 구분자(`//구분자\n숫자들`) 형식
- 특수문자(`*`, `+` 등)도 `Pattern.quote()`로 안전하게 처리
- 커스텀 구분자와 기본 구분자(, :)를 함께 사용할 수 있음 (예: //^\n5^2:5)
- 숫자는 커스텀 구분자로 사용할 수 없음 (예: //6\n56 → 예외 발생)

**숫자 변환 및 검증**
- 문자열을 정수 배열로 변환
- 빈 토큰, 숫자 외 값, 음수 모두 예외 처리
- 음수는 모두 수집해서 한 번에 표시
- 모든 검증을 통과한 숫자들의 합을 계산해 출력

**입력 유효성에 대한 판단 기준**

- 단순히 예외를 던지는 것보다 어떤 입력을 허용하고 비허용할지 고민했습니다.
- 예를 들어 "005"나 "07:5"처럼 0으로 시작하는 입력도 실제로는 정상적인 숫자로 처리되도록 구현했습니다.
- 공백을 커스텀 구분자로 지정하는 것은 사용자 혼동을 막기 위해 제한했습니다.
- 이를 통해 프로그램이 예상치 못한 형태의 입력에도 유연하게 동작하도록 만들었습니다.

---

## 실행 예시

```
덧셈할 문자열을 입력해 주세요.
3,2:5
결과 : 10
```

```
덧셈할 문자열을 입력해 주세요.
//;\n1;2;4
결과 : 7
```

```
덧셈할 문자열을 입력해 주세요.
-5,2,-3
잘못된 입력: 음수는 허용되지 않습니다: -5, -3
```

---

## 코드 구조

처음엔 `Application` 하나에 모든 기능을 넣었지만, 점점 구조를 나누는 게
낫겠다는 생각이 들었습니다. 그래서 입력, 계산, 출력을 각각의 책임으로
분리해봤습니다.

- `Application`: 전체 흐름 제어
- `view/InputView`: 사용자 입력
- `view/OutputView`: 결과 출력
- `service/CalculatorService`: 파싱 및 계산
- `domain/NumberParser`: 숫자 변환 및 검증
- `util/StringUtils`: 공통 문자열 검증

---

## 구현하면서 고민했던 부분

### 음수 입력 처리에 대한 고민
처음에는 음수가 하나라도 들어오면 바로 예외를 던지도록 했습니다.
그런데 음수는 문자열처럼 눈에 잘 드러나지 않아 사용자가 놓칠 수 있다고 생각했습니다.
그래서 입력된 모든 음수를 한 번에 모아 예외 메시지로 보여주도록 수정했습니다.

### 책임을 나누는 과정
입력부터 출력까지 전부 한 파일에 있던 코드를 분리하는 게 처음엔 더 어렵게 느껴졌습니다.  
하지만 분리하고 나니 테스트하기도 수정하기도 훨씬 수월했습니다.  
특히 콘솔 입출력에 의존하지 않게 되면서 나중에 웹이나 파일 입력으로 바꿔도 구조를 그대로 활용할 수 있을 것 같았습니다.

### 커스텀 구분자에서의 시행착오
커스텀 구분자 기능을 추가했을 때 `split()`이 계속 깨져서 원인을 찾는 데 시간이 걸렸습니다.
문제는 `*`, `+` 같은 특수문자가 정규식으로 해석되고 있었던 것이었습니다.
`Pattern.quote()`를 적용한 뒤에야 정상적으로 동작했습니다.
이 경험을 통해 작동하는 코드와 안전한 코드는 다를 수 있다는 걸 배웠습니다.

### 개행 문자 처리의 함정
커스텀 구분자 테스트가 계속 실패해서 원인을 찾는 데 꽤 오래 걸렸습니다.  
콘솔 입력에서는 실제 개행(`\n`)이 들어오지만 테스트 문자열은 리터럴(`\\n`)이 들어왔던 문제였습니다.  
개행 문자를 replaceAll("\\r\\n|\\r|\\n", "\n")로 정규화하여 해결했습니다.  
이 경험을 통해 입력 환경에 따라 문자열이 다르게 들어올 수 있다는 점을 배웠습니다.

### 공백 문자로 인한 혼동 해소 
공백은 구분자로 사용할 수 있지만 시각적으로 구분이 어렵다고 판단했습니다.  
예를 들어 <code>// \n1&nbsp;2&nbsp;&nbsp;3</code>처럼 공백이 여러 번 입력되거나 <code>//&nbsp;&nbsp;\n1&nbsp;2&nbsp;3</code>처럼
구분자 부분의 공백 개수가 다르면 사용자가 오류의 원인을 찾기 어렵습니다.  
이런 혼동을 막기 위해 공백을 커스텀 구분자로 지정하는 것은 제한했습니다.

---

## 배운 점

이번 과제를 통해 코드가 길어질수록 구조적으로 **쉽게 읽히는 코드**가 중요하다는 걸 많이 느꼈습니다.  
변수명 하나, 메서드 이름 하나를 정할 때마다 어떤 표현이 더 직관적인가를 많이 생각했습니다.  
시간이 더 걸렸지만 누가 봐도 어떤 역할인지 바로 알 수 있도록 표현하려고 노력했습니다.

코드를 다 만든 뒤 테스트를 작성하면서 **TDD의 필요성**을 실감했습니다.  
다음엔 구현보다 테스트를 먼저 써보고 싶습니다.  
테스트가 있으면 리팩토링도 훨씬 자신 있게 할 수 있을 것 같습니다.

마지막으로 **작은 단위로 커밋하는 습관**의 중요성도 느꼈습니다.  
한 번에 여러 기능을 커밋했을 때는 변경 내용을 찾기 어려웠지만  
작은 단위로 나누니 이력이 깔끔해지고 문제 원인도 빠르게 추적할 수 있었습니다.